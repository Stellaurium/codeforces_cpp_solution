我知道这个题不可以贪心，
因为这个后面可能剩下别的字符，
下一次开始的位置就不固定了。
我也知道从不同的字母开始，对一个字符串的效果完全不一样
然后就放弃做了

简单瞄了一眼题解，让我用动态规划
(其实贪心做不出来，下一步就应该想想是不是能动态规划)
但是看了也没有想法，估计还是做题少了

简单瞄了一眼solution 
然后有了灵感：对每一个string
动态规划开始的字母，可以得到结束的字母，以及这个字符串的得分
然后我们只需要用上面动态规划的结果 O(1) 时间，添加一个字符串

但是最后的复杂度怎么还是 O(2^n + n*m)


---

再看答案后的想法：
再添加一个新的保存最大值的数组
描述从 头到当前位置i，并且以j结尾的答案的最大值是多少

---

捋顺整个流程

首先需要一个 max_value[i,j] 表示最大值
即在使用前i个字符串的情况下，以j字符结尾的最大值。
当i=0的时候，即什么都不用，只能产生空串，
因此max_value[0,0] = 0 ，其余都为-inf

然后讨论每一个字符串的对于不同输入情况的输出：
对于5种不同的期望的输入，执行模拟，算出分数，
然后加到之前的max_value之上，更新max_value

最终找到最大的max_value即可


















